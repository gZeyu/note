# 139. Word Break

>  **Related Topics:** 动态规划，回溯，DFS

Given a  **non-empty**  string  _s_  and a dictionary  _wordDict_  containing a list of  **non-empty**  words, determine if  _s_  can be segmented into a space-separated sequence of one or more dictionary words.

**Note:**

-   The same word in the dictionary may be reused multiple times in the segmentation.
-   You may assume the dictionary does not contain duplicate words.

**Example 1:**

**Input:** s = "leetcode", wordDict = ["leet", "code"]
**Output:** true
**Explanation:** Return true because `"leetcode"` can be segmented as `"leet code"`.

**Example 2:**

**Input:** s = "applepenapple", wordDict = ["apple", "pen"]
**Output:** true
**Explanation:** Return true because `"`applepenapple`"` can be segmented as `"`apple pen apple`"`.
             Note that you are allowed to reuse a dictionary word.

**Example 3:**

**Input:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
**Output:** false
## Approach 1
### 思路
可以使用动态规划求解该问题。令$s_{j,i}$表示范围[j, i)的子串，$dp[i]$表示$s_{0,i}$能否拆分成字典内的单词。如果能在[0,i )中找到分割点$j$，使得$s_{0,j}$可以被拆分成字典内的单词，且$s_{j,i}$为字典内的单词，那么说明$s_{0,i}$也可以被拆分成字典内的单词，即$dp[i]=true$。因此我们得到如下递归方程:
$$
dp[i] = 
\begin{cases}
 true &if\; i=0\\
 true &if\; dp[j]=ture \;and  \;s_{j,i}\in wordDict, j\in[0,i )\\
 false &if\; dp[j]=false \;or  \;s_{j,i}\notin wordDict, j\in[0,i )\\
 \end{cases}
 $$

### Java Code
``` Java
import java.util.*;  
  
class Solution {  
  
  public static void main(String[] args) {  
    Solution s = new Solution();  
    List<String> wordDict = new ArrayList<>();  
    Collections.addAll(wordDict, "cats", "dog", "sand", "and", "cat");  
    System.out.println(s.wordBreak("catsandog", wordDict));  
    wordDict.clear();  
    Collections.addAll(wordDict, "apple", "pen");  
    System.out.println(s.wordBreak("applepenapple", wordDict));  
  }  
  
  public boolean wordBreak(String s, List<String> wordDict) {  
    boolean[] dp = new boolean[s.length() + 1];  
    Set<String> set = new HashSet<>(wordDict);  
    dp[0] = true;  
    for (int i = 1; i <= s.length(); i++) {  
      for (int j = 0; j < i; j++) {  
        if (dp[j] && set.contains(s.substring(j, i))) {  
          dp[i] = true;  
          break;  
        }  
      }  
    }  
    return dp[s.length()];  
  }  
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MDM3MTEyOTAsLTIwMTI4NzAwNywxMT
Y1MDQxNjQsMzA4OTAyMjI2LDM0MTgzNzQyOCwxODIzNTE0ODkw
LDYzMDM0Mzg0N119
-->