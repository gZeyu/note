# 140. Word Break II

>  **Related Topics:** 

## Approach 1
### 思路
可以使用回溯法求解该问题。该问题等价于能否寻找一个能够拆解字符串$s$为字典内单词的可行解，假设解可以由向量$(x_1,x_2,...,x_n)$表示，$x_i\in wordDict$。假设已经知道部分解$(x_i,x_2,...,x_{i-1})$，由于$x_i\in wordDict$，则遍历$wordDict$，对$x_i$进行试探取值。若$(x_1,x_2,...,x_i)$为字符串$s$的前缀，因此可以继续往下搜索，即从搜索树的第$i$层进入第$i+1$层；如果遍历整个$wordDict$都未找到满足条件的$x_i$的取值，则回溯到第$i-1$层，尝试$x_{i-1}$的其他值继续搜索。
可以注意到搜索过程中对于同一个前缀可能存在大量重复的可行解，我们没必要计算同一个前缀的所有可行解，故此时我们可以通过维护一个一维$visited$数组，对搜索树进行剪枝。$visited[k]=true$表示长度为k-1的前缀在之前的搜索中已经计算过了，可以直接回溯。
### Java Code
``` Java
import java.util.*;  
  
class Solution {  
  
  public List<String> wordBreak(String s, List<String> wordDict) {  
    Map<Integer, List<String>> visited = new HashMap<>();  
    wordBreakCore(s, wordDict, 0, visited);  
    return visited.get(0);  
  }  
  
  private void wordBreakCore(  
      String s, List<String> wordDict, int begin, Map<Integer, List<String>> visited) {  
    if (begin == s.length() || visited.containsKey(begin)) {  
      return;  
    }  
    List<String> list = new ArrayList<>();  
    for (String word : wordDict) {  
      int end = begin + word.length();  
      if (end <= s.length() && word.equals(s.substring(begin, end))) {  
        wordBreakCore(s, wordDict, end, visited);  
        if (end < s.length() && !visited.get(end).isEmpty()) {  
          for (String str : visited.get(end)) {  
            list.add(word + " " + str);  
          }  
        } else if (end == s.length()) {  
          list.add(word);  
        }  
      }  
    }  
    visited.put(begin, list);  
  }  
  
  public static void main(String[] args) {  
    Solution s = new Solution();  
    System.out.println(  
        s.wordBreak("catsanddog", Arrays.asList("cat", "cats", "and", "sand", "dog")));  
    System.out.println(  
        s.wordBreak(  
            "pineapplepenapple", Arrays.asList("apple", "pen", "applepen", "pine", "pineapple")));  
    System.out.println(  
        s.wordBreak("catsandog", Arrays.asList("cats", "dog", "sand", "and", "cat")));  
    System.out.println(  
        s.wordBreak(  
            "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",  
            Arrays.asList(  
                "a",  
                "aa",  
                "aaa",  
                "aaaa",  
                "aaaaa",  
                "aaaaaa",  
                "aaaaaaa",  
                "aaaaaaaa",  
                "aaaaaaaaa",  
                "aaaaaaaaaa")));  
  }  
}
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAyMjM4ODQxMl19
-->